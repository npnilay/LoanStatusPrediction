# -*- coding: utf-8 -*-
"""Loanstatus.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nc1A3kbpJdL45K7zq-pLYWKC1c0_J962
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import scipy.stats as stats
# %matplotlib inline
plt.rcParams['figure.figsize'] = 10, 8
plt.style.use("seaborn")

import statsmodels.formula.api as sm
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import cross_validate

bankloans = pd.read_csv("/content/bankloans.csv")
bankloans.head()
bankloans.columns
#number of observations and features
bankloans.shape
#data types in the dataframe
bankloans.info()
#check for any column has missing values
bankloans.isnull().any()
#check for number of missing values
bankloans.isnull().sum()

#Segregating the numeric and categorical variable names
numeric_var_names = [key for key in dict(bankloans.dtypes) if dict(bankloans.dtypes)[key] in ['float64', 'int64', 'float32', 'int32']]
catgorical_var_names = [key for key in dict(bankloans.dtypes) if dict(bankloans.dtypes)[key] in ['object']]
numeric_var_names
#splitting the data set into two sets - existing customers and new customers
bankloans_existing = bankloans.loc[bankloans.default.isnull() == 0]

bankloans_new = bankloans.loc[bankloans.default.isnull() == 1]
bankloans_existing.describe(percentiles=[.25,0.5,0.75,0.90,0.95])
sns.boxplot(y = "age",data=bankloans_existing)
plt.title("Box-Plot of age")
plt.show()
sns.boxplot(y = "employ",data=bankloans_existing)
plt.title("Box-Plot of employee tenure")
plt.show()
sns.boxplot(y = "income",data=bankloans_existing)
plt.title("Box-Plot of employee income")
plt.show()
sns.boxplot(y = "debtinc",data=bankloans_existing)
plt.title("Box-Plot of employee debt to income ratio")
plt.show()
sns.boxplot(y = "creddebt",data=bankloans_existing)
plt.title("Box-Plot of Credit to debit ratio")
plt.show()

income_minlimit = bankloans_existing["income"].quantile(0.75) + 1.5 * (bankloans_existing["income"].quantile(0.75) - bankloans_existing["income"].quantile(0.25))
income_minlimit
def outlier_capping(x):
  x = x.clip_upper(x.quantile(0.95))
  return(x)

bankloans_existing.corr()

sns.heatmap(bankloans_existing.corr(),annot=True,fmt="0.2f",cmap="coolwarm")
plt.show()
bankloans_existing.shape
bankloans_new.shape
#Indicator variable unique types
bankloans_existing['default'].value_counts()
bankloans_existing['default'].value_counts().plot.bar()
plt.xlabel("default")
plt.ylabel("count")
plt.title("Distribution of default")
plt.show()

#percentage of unique types in indicator variable
  round(bankloans_existing['default'].value_counts()/bankloans_existing.shape[0] * 100,3)
  ## performing the independent t test on numerical variables
  tstats_df = pd.DataFrame()
  for eachvariable in numeric_var_names:
     tstats = stats.ttest_ind(bankloans_existing.loc[bankloans_existing["default"] == 1,eachvariable],bankloans_existing.loc[bankloans_existing["default"] == 0, eachvariable],equal_var=False)
     temp = pd.DataFrame([eachvariable, tstats[0], tstats[1]]).T
     temp.columns = ['Variable Name', 'T-Statistic', 'P-Value']
     tstats_df = pd.concat([tstats_df, temp], axis=0, ignore_index=True)
     tstats_df = tstats_df.sort_values(by = "P-Value").reset_index(drop = True)
     tstats_df

def BivariateAnalysisPlot(segment_by):
  fig, ax = plt.subplots(ncols=1,figsize = (10,8))
#boxplot
  sns.boxplot(x = 'default', y = segment_by, data=bankloans_existing)
  plt.title("Box plot of "+segment_by)
  plt.show()
  BivariateAnalysisPlot("age")
  BivariateAnalysisPlot("ed")
  BivariateAnalysisPlot("employ")
  BivariateAnalysisPlot("address")
  BivariateAnalysisPlot("income")
  BivariateAnalysisPlot("debtinc")
  BivariateAnalysisPlot("creddebt")
  BivariateAnalysisPlot("othdebt")

decisiontree_hyperparameters = {
'decisiontreeclassifier__max_depth' : np.arange(3, 10),
'decisiontreeclassifier__max_features' : np.arange(3, 8),
'decisiontreeclassifier__min_samples_split' : np.arange(2, 15),
"decisiontreeclassifier__min_samples_leaf" : np.arange(1,3)
}

dtclass_model = GridSearchCV(pipelines['dtclass'],decisiontree_hyperparameters,cv=5, n_jobs=-1)
#fit the model

